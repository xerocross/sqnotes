#!/usr/bin/env python3

import argparse
import os
import glob
import subprocess
import tempfile
import configparser
from pathlib import Path
from datetime import datetime

# Configurable directory for storing notes
NOTE_DIR = os.path.expanduser("~/sqnotes")
CONFIG_FILE = os.path.expanduser("~/.sqnotes_config")

# Load configuration
config = configparser.ConfigParser()
if os.path.exists(CONFIG_FILE):
    config.read(CONFIG_FILE)

# Function to save configuration
def save_config():
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)

# Function to get configured text editor, defaulting to None if not set
def get_text_editor():
    if 'settings' in config and 'text_editor' in config['settings']:
        return config['settings']['text_editor']
    else:
        return None

# Function to check if a text editor is available
def is_text_editor_available(editor):
    try:
        subprocess.run([editor, '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except FileNotFoundError:
        return False

# Prompt user to select a text editor if not configured
def prompt_select_text_editor():
    editors = ['vim', 'nano', 'emacs', 'gedit']  # List of common terminal text editors
    available_editors = [editor for editor in editors if is_text_editor_available(editor)]

    if not available_editors:
        print("Error: No compatible text editor found.")
        print("Please install one of the following editors: vim, nano, emacs, gedit")
        exit(1)

    print("Select a text editor to use:")
    for idx, editor in enumerate(available_editors, start=1):
        print(f"{idx}. {editor}")

    choice = input("Enter the number of your choice: ")
    try:
        choice_idx = int(choice) - 1
        selected_editor = available_editors[choice_idx]
        config['settings']['text_editor'] = selected_editor
        save_config()
        print(f"Text editor set to: {selected_editor}")
        return selected_editor
    except (ValueError, IndexError):
        print("Invalid choice. Using default editor.")
        return None

# Set text editor configuration
def set_text_editor(editor):
    if is_text_editor_available(editor):
        config['settings']['text_editor'] = editor
        save_config()
        print(f"Text editor set to: {editor}")
    else:
        print(f"Error: {editor} is not installed. Please choose a different editor.")

# Function to check if GPG key email is configured
def check_gpg_key_email():
    if 'settings' not in config or 'gpg_key_email' not in config['settings']:
        print("Error: GPG key email not set.")
        print("Please set the GPG key email using:")
        print("  sqnotes --set-gpg-key your_email@example.com")
        exit(1)

# Function to add a new note
def add_note():
    check_gpg_key_email()

    # Ensure a text editor is configured
    TEXT_EDITOR = get_text_editor()
    if TEXT_EDITOR is None:
        TEXT_EDITOR = prompt_select_text_editor()
        if TEXT_EDITOR is None:
            print("No text editor selected. Exiting.")
            exit(1)

    # Create a temporary file for the new note
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        temp_filename = temp_file.name

    # Open the configured text editor to edit the note
    subprocess.call([TEXT_EDITOR, temp_filename])

    # Read the content from the temporary file
    with open(temp_filename, 'r') as file:
        note_content = file.readlines()

    # Append the signature text
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
    gpg_signature = f"[{config['settings']['gpg_key_email']}] [{timestamp}]"
    note_content[-1] = note_content[-1].strip() + ' ' + gpg_signature + '\n'

    # Write the modified content back to the temporary file
    with open(temp_filename, 'w') as file:
        file.writelines(note_content)

    # Save the encrypted note content to a new note file
    note_id = len(glob.glob(f"{NOTE_DIR}/*.gpg")) + 1
    note_filename = os.path.join(NOTE_DIR, f"note_{note_id}.txt.gpg")
    with tempfile.NamedTemporaryFile(delete=False) as temp_enc_file:
        temp_enc_filename = temp_enc_file.name
        temp_enc_file.write(''.join(note_content).encode('utf-8'))

    # Encrypt the note using the configured GPG key email's public key
    subprocess.call(['gpg', '--output', note_filename, '--encrypt', '--recipient', config['settings']['gpg_key_email'], temp_enc_filename])
    os.remove(temp_enc_filename)
    print(f"Note added: {note_filename}")

    # Delete the temporary file
    os.remove(temp_filename)
    
    

# Function to search notes
def search_notes(search_queries):
    check_gpg_key_email()

    # Convert all search queries to lowercase
    search_queries_lower = [query.lower() for query in search_queries]

    # Search for the queries in all notes
    for filename in glob.glob(f"{NOTE_DIR}/*.gpg"):
        with tempfile.NamedTemporaryFile(delete=False) as temp_dec_file:
            temp_dec_filename = temp_dec_file.name

        # Decrypt the note
        subprocess.call(['gpg', '--yes', '--batch', '--quiet', '--output', temp_dec_filename, '--decrypt', filename])

        with open(temp_dec_filename, 'r') as file:
            content = file.read()
            content_lower = content.lower()  # Convert note content to lowercase

            # Check if all search queries are in the note content
            if all(query in content_lower for query in search_queries_lower):
                print(f"\n{filename}:\n{content}")

        os.remove(temp_dec_filename)

# Function to edit a note
def edit_note(filename):
    check_gpg_key_email()
    note_path = os.path.join(NOTE_DIR, filename)
    if not os.path.exists(note_path):
        print(f"Note not found: {filename}")
        return

    # Ensure a text editor is configured
    TEXT_EDITOR = get_text_editor()
    if TEXT_EDITOR is None:
        TEXT_EDITOR = prompt_select_text_editor()
        if TEXT_EDITOR is None:
            print("No text editor selected. Exiting.")
            exit(1)

    # Decrypt the note to a temporary file
    with tempfile.NamedTemporaryFile(delete=False) as temp_dec_file:
        temp_dec_filename = temp_dec_file.name

    subprocess.call(['gpg', '--output', temp_dec_filename, '--decrypt', note_path])

    # Open the note with the configured text editor
    subprocess.call([TEXT_EDITOR, temp_dec_filename])

    # Encrypt the edited note back to the original file
    subprocess.call(['gpg', '--output', note_path, '--encrypt', '--recipient', config['settings']['gpg_key_email'], temp_dec_filename])
    os.remove(temp_dec_filename)

# Function to run a git command in the sqnotes directory
def run_git_command(args):
    subprocess.call(['git'] + args, cwd=NOTE_DIR)

# Main function
def main():
    parser = argparse.ArgumentParser(description='SQNote: Secure note-taking script')
    parser.add_argument('-n', '--new', help='Add a new note', action='store_true')
    parser.add_argument('-f', '--find', nargs='+', help='Find a note')  # Allow multiple search queries
    parser.add_argument('-e', '--edit', help='Edit a note', type=str)
    parser.add_argument('--git', nargs=argparse.REMAINDER, help='Run a git command in the sqnotes directory')
    parser.add_argument('--set-gpg-key', help='Set the GPG Key', type=str)
    parser.add_argument('--set-text-editor', help='Set the text editor (vim, nano, emacs, gedit)', type=str, choices=['vim', 'nano', 'emacs', 'gedit'])

    args = parser.parse_args()

    if args.set_gpg_key:
        set_gpg_key_email(args.set_gpg_key)
    elif args.set_text_editor:
        set_text_editor(args.set_text_editor)
    elif args.new:
        add_note()
    elif args.find:
        search_notes(args.find)
    elif args.edit:
        edit_note(args.edit)
    elif args.git:
        run_git_command(args.git)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()

